# Redis数据类型总结

*   Redis中丰富的数据类型，以及其高速的缓存机制（利用将数据保存在内存中），使得越来越多的人利用Redis做数据存储。那么它的丰富数据类型主要包含了以下几个：
    *   简单的动态字符串(SDS)
        *   **字符串**是Redis的核心字符串，串通了整个开源框架，几乎所有需要用到字符串的地方都需要SDS。
    *   链表
        *   **链表**与我们平时所学的队列形式类似，但是其结构更见明显清晰，包含了prev以及next指针，分别指向上一个节点以及下一个节点，还包含了当前的结构体所要包含的void\*指针（多态），而Redis特别之处就在于，它会利用一个list结构去持有整个链表，list中包含了链表头节点地址，链表尾结点地址，链表长度，这都使得例如获取链表长度的时间复杂度为O(1)一系列方便性，list中还包含着对应于void\*指针的一系列操作函数，这些都可以是被设置的，多态的效果。
    *   字典
        *   **字典**的底层实现则是利用了哈希表(dicht)、哈希表节点(dictEntry)，首先的包裹关系是结构体哈希表持有dictEntry** table（二维数组，感觉是可以替换的），这里的dictEntry** table二级指针主要还是为了存储类似于（键-（键-值））这种类型，其实我认为这个table也是可以被替换的，但是对于字典来说的话，这里存储二级的dictEntry** table也是没有什么毛病的。
        *   它的一级指针则指向了一个哈希索引（根据最外层的键由哈希算法算出来的哈希值->索引值），索引值会造成哈希冲突，解决哈希冲突最经典的办法则是拉链法，而Redis也是使用拉链法解决哈希冲突的，在disctEntry结构体内部保存着下一个实体的指针(struct dictEntry\* next)，则是拉链法的使用。
        *   **字典**则持有整个哈希表，实际上是持有两个哈希表dictht ht[2]，一般来说操作通常会在第一个哈希表ht[0]进行，而只有希望rehash的使用，第二个哈希表ht[1]才会发挥作用，重哈希是因为负载因子过高/过小的原因，过高会造成哈希表某一个索引上聚集大量的冲突，查询速度变慢，国小则是会过于浪费内存空间需要释放。
        *   rehash的过程是渐进式的，因为如果hash表中的键值对保存了大量的数据，此时如果一次性rehash必然会造成服务的暂停，为了确保服务不会被长时间地停止，因此渐进式rehash是必然的，rehashindx则记录了hash过程，-1表示目前没有进行rehash。
    *   跳跃表
        *   跳跃表在Redis只用了两次，一个是实现有序集合的键，另一个是在集群节点中作内部数据结构用途。即使跳跃表用途不广泛但是它还是非常的有意义。
        *   跳跃表（zskiplist）特别的地方在于struct zskiplistLevel结构体被定义为level[]数组，而每一个level包含了forward指针以及其forward的跨度，每添加一个节点的时候，会随机初始化这个level含有的层数（数组数量，1-32，不含0是因为至少有一层，不然会跳跃表会中断），随机化level层数带来的效果就是，下一个节点中可能并无对应相同的level层，因此从这个指针访问就有可能产生跳跃性的访问后几个节点。而分值通常是有序的，若是查找特定的键，可以通过判断节点中分值的大小从而推断是否可能超过了需要寻找的分值。
        *   跳跃表的连续访问也是非常简单的，只需要从高处往低处寻找跨度为1的forward指针即可连续遍历这个跳跃表，节点头也包含了头节点以及尾节点的指针，通过这个指针能快速访问头尾节点。
        *   跳跃表还包含了后退指针，后退指针并无跳跃性所言，跨度始终为1，这只是为了从尾到头的遍历需求。
    *   整数集合
        *   整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现，其实这个整数集合，完全是一个没有优化过的整数数组（我认为）。
        *   整数集合结构体简单的包含了三个部分：encoding, length, contents[]。编码方式的存在使得整数集合会有升级的状况出现，当content[]包含了不同类型的整数时，以需要最多位数的为主。整数集合不支持降级操作。
    *   压缩列表
        *   压缩列表(ziplist)也可以作为哈希键或者列表键的底层实现。适用于整数值较小，以及字符串长度较小的的键，利用压缩列表可以有效地节省内存使用，因为压缩列表是一段连续的内存块组成的顺序型数据结构。
        *   压缩列表要包含五个模块：zlbytes（记录整个压缩列表占用的内存字节数）、zltail（记录压缩列表表尾距离压缩列表起始位置的距离字节）、zllen（记录压缩列表的节点数）、entry（压缩列表节点）、zlend（0xff标志结尾）。
        *   每一个压缩列表节点entry包含了三个部分：previous_entry_length（可以用来从后往前访问这个压缩列表、其字节长度跟随内容变化、引起连锁更新的主要原因）、encoding（编码方式，类型在前长度在后），00 01 10表示 1 2 5字节（这个字节长度表示的是encoding的长度）长度的数组编码，11表示 1 字节长的整数编码，contents数组的长度在encoding除去最高两位的后面所有位数表示。



