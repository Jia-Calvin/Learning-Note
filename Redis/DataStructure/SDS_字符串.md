## 简单动态字符串（Simple dynamic string, **SDS**）

* Redis中经常要用到字符串，比如我们设置的键与值：set msg "Hello World"，这些键与值都需要保存下来，那么Redis就利用字符串结构体保存这些字符串。

*   Redis并没有用传统的**C语言字符串**来表示（以空字符结尾的字符数组，C字符串），而是构建了自己的**动态字符串结构体SDS** ：
    ``` c
        // 需要注意的是，len + free = 申请的空间
        struct sdshrd {
            // 记录已申请空间中已使用的长度
            int len;
            // 记录已申请空间中未使用的长度
            int free;
            // 字符数组，保存数据
            char buf[];
        }
    ```
*   Redis使用构建的动态字符串对比与传统C语言所产生的好处在于：
    *   常数复杂度获取字符串的长度，C字符串主要是遍历遇到空字符则返回其长度O(n)，而Redis可以直接访问SDS的**len**就可以获取其长度O(1)。
    *   解决缓冲区溢出问题，C语言中许多字符串操作都是需要预先分配好空间的，如果执行字符串操作函数，例如执行 char* strcat(char *dest, cons char *src) 时，没有对dest提前赋予足够的空间，则会**造成dest数据溢出到保存在它（内存位置）后面的数据（覆盖）**，导致别的数据被污染。而SDS的空间分配（空间预分配）策略杜绝这种情况，会检查是否有足够（检查free的大小）的空间去容纳字符串，避免这个问题。
    *   空间预分配策略与惰性空间释放减少修改字符串时带来的内存重分配（系统调用）次数：
        *   空间预分配：
            *   分配后小于1MB，则使len=free，分配多一倍。
            *   分配后大于1MB，则多分配1MB。
        *   惰性空间删除：
            *   不立即删除空间（不马上free），而是利用结构体的int free记录下来，以后可能会用到，避免再分配。
    *   SDS本身不存在以空字符结尾则保证了二进制安全性，SDS通过len来判断字符串长度的，不以'\0'来判断，所以在存储的 char buf[] 中含有'\0'或是其他字符都是可以的。
    *   兼容部分C字符串函数，strcasecmp(sds->buf, "hello world")，只要SDS遵循C字符串以空字符结尾这一个规则。
